# TR1
## Моделирование и разработка системы на основе принципов ООП

### Постановка задачи разработки ПО

Разрабатывается система для автоматизации поиска авиабилетов в туристическом агентстве. Основные требования:
- Получение данных о городах и рейсах через API
- Поиск по названию города (русский/английский)
- Отображение информации о рейсах (номер, время вылета, цена)
- Простота использования для сотрудников агентства

### Разработка классов системы

#### 1. Класс DataManagement (Управление данными)

**Ответственность**:
- Загрузка данных о городах из API
- Поиск городов по названию
- Получение информации о рейсах между городами
- Хранение и предоставление данных

**Реализация**:
```cpp
class DataManagement {
public:
    DataManagement(); // Конструктор с автоматической загрузкой данных
    
    int CitySearch(std::string nameCity); // Поиск города
    void GetDataJson(DataCity cityOne, DataCity cityTwo, std::string dataTime); // Получение данных о рейсах
    void ShowData(const int index); // Отображение информации о рейсе
    
    List<DataCity> lstCityData; // Список городов
    List<GettingDataCity> getterData; // Список рейсов
    
private:
    struct DataCity { // Структура данных города
        std::string code;
        std::string nameEn;
        std::string nameRu;
        std::string countryCode;
    };
    
    struct GettingDataCity { // Структура данных рейса
        std::string flight_number;
        std::string departure_at;
        int price;
    };
    
    static size_t WriteCallback(void* contents, size_t size, size_t nmemb, std::string* output);
    void GetJSON(); // Загрузка JSON
    std::string toLower(std::string str); // Вспомогательный метод
};
```

#### 2. Класс List (Шаблонный список)

**Ответственность**:
- Хранение данных любого типа
- Основные операции с элементами списка
- Управление памятью

**Реализация**:
```cpp
template <typename T>
class List {
public:
    List(); // Конструктор
    ~List(); // Деструктор
    
    // Основные методы
    void push_back(T data); // Добавление в конец
    void push_head(T data); // Добавление в начало
    T& operator[](const int index); // Доступ по индексу
    // ... другие методы
    
private:
    template<typename T1>
    class Node { // Внутренний класс узла
    public:
        T1 data;
        Node* pNext;
        Node(T1 data = T1(), Node* pNext = nullptr);
    };
    
    Node<T>* head; // Указатель на начало
    int size; // Размер списка
};
```

### Диаграмма классов

```
+-------------------+       +-------------------+
|   DataManagement  |       |      List<T>      |
+-------------------+       +-------------------+
| - lstCityData     |<>-----| - head: Node<T>*  |
| - getterData      |       | - size: int       |
+-------------------+       +-------------------+
| + CitySearch()    |               ^
| + GetDataJson()   |               |
| + ShowData()      |       +-------------------+
+-------------------+       |      Node<T1>     |
                            +-------------------+
                            | - data: T1        |
                            | - pNext: Node<T1>*|
                            +-------------------+
```

### Применение принципов ООП

1. **Инкапсуляция**:
   - Все внутренние структуры данных (Node) скрыты в private-секции
   - Доступ к данным осуществляется только через публичные методы
   ```cpp
   // Пример из DataManagement.cpp
   void DataManagement::GetJSON() {
       // Внутренняя реализация работы с API скрыта
   }
   ```

2. **Абстракция**:
   - Пользователю класса не нужно знать детали реализации работы с API
   - Простые методы для работы с системой:
   ```cpp
   // Пример использования из main.cpp
   int index = data.CitySearch("Москва");
   data.GetDataJson(data.lstCityData[index], ...);
   ```

3. **Шаблоны (Generics)**:
   - Класс List реализован как шаблонный, что позволяет использовать его для разных типов данных
   ```cpp
   List<DataCity> lstCityData; // Список городов
   List<GettingDataCity> getterData; // Список рейсов
   ```

4. **Модульность**:
   - Система разделена на логические модули (DataManagement, List)
   - Каждый класс имеет четко определенную ответственность

5. **Повторное использование кода**:
   - Класс List может использоваться в других проектах без изменений
   - Метод toLower используется в разных частях системы

### Примеры из кода

1. **Работа с API** (принцип единственной ответственности):
```cpp
void DataManagement::GetJSON() {
    CURL* curl;
    // Настройка и выполнение запроса
    // Обработка JSON ответа
}
```

2. **Поиск города** (принцип инкапсуляции):
```cpp
int DataManagement::CitySearch(std::string nameCity) {
    std::string lowerInput = toLower(nameCity);
    // Поиск в списке городов
    return foundIndex;
}
```

3. **Шаблонный список** (принцип обобщенного программирования):
```cpp
template <typename T>
class List {
    // Реализация работает для любого типа T
};
```

### Вывод

Разработанная система демонстрирует применение основных принципов ООП:
- Четкое разделение ответственности между классами
- Сокрытие реализации деталей
- Возможность повторного использования компонентов
- Гибкость за счет шаблонного программирования

Такой подход позволяет легко расширять функциональность системы и поддерживать код в будущем.
